{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PyStreamPU Python API documentation","text":"<p>This PyStreamPU is the Python API for StreamPU, a DSEL for streaming applications written in C++. For the documentation of the StreamPU C++ API see aff3ct.github.io/streampu.</p>"},{"location":"back_to_first_steps/","title":"Back to the first steps","text":"In\u00a0[2]: Copied! <pre>src = spu.source_random(8, dtype = spu.int64)\ninc = spu.incrementer(8, dtype=spu.int64)\n</pre> src = spu.source_random(8, dtype = spu.int64) inc = spu.incrementer(8, dtype=spu.int64) In\u00a0[3]: Copied! <pre>x,_ = src.generate()\ny = inc.increment(x)\n\nprint(\"Output of source:\", x)\nprint(\"Output of incrementer:\", y)\n</pre> x,_ = src.generate() y = inc.increment(x)  print(\"Output of source:\", x) print(\"Output of incrementer:\", y) <pre>Output of source: [[1 1 1 1 1 1 1 1]]\nOutput of incrementer: [[2 2 2 2 2 2 2 2]]\n</pre> In\u00a0[4]: Copied! <pre>src.generate.exec()\ninc.increment.exec()\nprint(\"Output of source:\", x)\nprint(\"Output of incrementer:\", y)\n</pre> src.generate.exec() inc.increment.exec() print(\"Output of source:\", x) print(\"Output of incrementer:\", y) <pre>Output of source: [[0 1 1 0 0 0 1 0]]\nOutput of incrementer: [[1 2 2 1 1 1 2 1]]\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"back_to_first_steps/#back-to-the-first-steps","title":"Back to the first steps\u00b6","text":"<p>Now that you are familiar with the StreamPU concepts of</p> <ul> <li>module</li> <li>task</li> <li>socket we will show how the previous steps can be simplified.</li> </ul>"},{"location":"back_to_first_steps/#build-the-modules","title":"Build the modules\u00b6","text":"<p>We keep the same example: suppose that we want to randomly generate <code>8</code> bits from a Bernoulli distribution and increment these bits.</p>"},{"location":"first_steps/","title":"First steps","text":"In\u00a0[1]: Copied! <pre>import streampu as spu\n</pre> import streampu as spu In\u00a0[2]: Copied! <pre>src = spu.source_random(8, dtype = spu.int64)\n</pre> src = spu.source_random(8, dtype = spu.int64) <p>If you want to have some information about the tasks of <code>src</code> you can use <code>help</code>or <code>spu.help</code>.</p> In\u00a0[3]: Copied! <pre>spu.help(src)\n</pre> spu.help(src) <pre># module:\n# |- name: Source_random\n# |- short name: Source\n# |- n_frames: 1\n# |- tasks:\n# |  |- name: generate\n# |  |  |- sockets out:\n# |  |  |  |- out_data: { n_elts = 8, datatype = int64 }\n# |  |  |  |- out_count: { n_elts = 1, datatype = uint32 }\n# |  |  |  |- status: { n_elts = 1, datatype = int32 }\n\n</pre> <p>In this log, we see that <code>src</code> has one <code>task</code> named <code>generate</code> that has 3 outputs:</p> <ul> <li><code>out_data</code>: 8 elements of type <code>int64</code></li> <li><code>out_count</code>: 1 element of type <code>uint32</code></li> <li><code>status</code>: 1 element of type <code>int32</code></li> </ul> <p>We will access the task <code>tsk</code>of a module <code>mdl</code> using the syntax <code>mdl['tsk']</code>. Similarly, the socket <code>sck</code>of the task <code>tsk</code> of a module <code>mdl</code> can be accessed using <code>mdl['tsk::sck']</code></p> In\u00a0[4]: Copied! <pre>src['generate'].exec()\n</pre> src['generate'].exec() <p>The generated bits, contained in the socket <code>out_data</code> can be read.</p> In\u00a0[5]: Copied! <pre>print(src['generate::out_data'])\n</pre> print(src['generate::out_data']) <pre>[[1 1 1 1 1 1 1 1]]\n</pre> In\u00a0[6]: Copied! <pre>inc = spu.incrementer(8, dtype=spu.int64)\n</pre> inc = spu.incrementer(8, dtype=spu.int64) <p>When asking for more details about <code>inc</code> we can see that it has two tasks named <code>increment</code> and <code>incrementf</code>. We will use <code>increment</code>. The task <code>increment</code> has one input socket called <code>in</code>.</p> In\u00a0[7]: Copied! <pre>spu.help(inc)\n</pre> spu.help(inc) <pre># module:\n# |- name: Incrementer\n# |- short name: Incrementer\n# |- n_frames: 1\n# |- tasks:\n# |  |- name: increment\n# |  |  |- sockets in:\n# |  |  |  |- in: { n_elts = 8, datatype = int64 }\n# |  |  |- sockets out:\n# |  |  |  |- out: { n_elts = 8, datatype = int64 }\n# |  |  |  |- status: { n_elts = 1, datatype = int32 }\n# |  |- name: incrementf\n# |  |  |- sockets in:\n# |  |  |  |- fwd: { n_elts = 8, datatype = int64 }\n# |  |  |- sockets out:\n# |  |  |  |- status: { n_elts = 1, datatype = int32 }\n\n</pre> In\u00a0[8]: Copied! <pre>inc['increment::in'] = src['generate::out_data']\n</pre> inc['increment::in'] = src['generate::out_data'] <p>This line is schematically equivalent to the following figure.</p> <p></p> In\u00a0[9]: Copied! <pre>src['generate'].exec()\ninc['increment'].exec()\n\nprint(\"Output of source:\", src['generate::out_data'])\nprint(\"Output of incrementer:\", inc['increment::out'])\n</pre> src['generate'].exec() inc['increment'].exec()  print(\"Output of source:\", src['generate::out_data']) print(\"Output of incrementer:\", inc['increment::out']) <pre>Output of source: [[0 1 1 0 0 0 1 0]]\nOutput of incrementer: [[1 2 2 1 1 1 2 1]]\n</pre> In\u00a0[10]: Copied! <pre>src['generate'].debug = True\ninc['increment'].debug = True\nsrc['generate'].exec()\ninc['increment'].exec()\n</pre> src['generate'].debug = True inc['increment'].debug = True src['generate'].exec() inc['increment'].exec() <pre># Source_random::generate(int64 out_data[8], uint32 out_count[1])\n</pre> <pre># {OUT} out_data  = [    1,     0,     0,     0,     1,     1,     1,     0]\n</pre> <pre># {OUT} out_count = [    8]\n</pre> <pre># Returned status: [0 'SUCCESS']\n</pre> <pre>#\n</pre> <pre># Incrementer::increment(const int64 in[8], int64 out[8])\n</pre> <pre># {IN}  in  = [    1,     0,     0,     0,     1,     1,     1,     0]\n</pre> <pre># {OUT} out = [    2,     1,     1,     1,     2,     2,     2,     1]\n</pre> <pre># Returned status: [0 'SUCCESS']\n</pre> <pre>#\n</pre>"},{"location":"first_steps/#first-steps","title":"First steps\u00b6","text":"<p>This section presents the first steps for playing with StreamPU in Python. It covers the following key concepts of StreamPU:</p> <ul> <li>module</li> <li>task</li> <li>socket</li> </ul> <p>At the end of this section, you should be able to :</p> <ul> <li>Create a module</li> <li>Get information about the task of a module</li> <li>Bind two sockets</li> <li>Execute a task of a module</li> <li>Read the values of a socket</li> <li>Activate the debug mode of a task</li> </ul>"},{"location":"first_steps/#import-streampu","title":"Import StreamPU\u00b6","text":"<p>As every Python package <code>StreamPU</code>is imported using the <code>import</code> interface.</p>"},{"location":"first_steps/#build-a-module","title":"Build a module\u00b6","text":"<p>Basically, a <code>module</code> is a device that can process data. A data processing is called a <code>task</code> in the StreamPU DSEL language. Modules can store several tasks as well as shared data for the different tasks or for different executions of the same tasks. Tasks exchange data through <code>sockets</code>.</p> <p>For example suppose that we want to randomly generate <code>8</code> bits from a Bernoulli distribution.</p>"},{"location":"first_steps/#execute-a-task","title":"Execute a Task\u00b6","text":"<p>To fill these sockets, let us execute the task <code>generate</code> of <code>src</code>.</p>"},{"location":"first_steps/#second-module-building","title":"Second module building\u00b6","text":"<p>We now want to incerement the bits of <code>out_data</code>. To do so, we start by building an <code>incrementer</code> (which is a also a <code>module</code>).</p>"},{"location":"first_steps/#module-binding","title":"Module binding\u00b6","text":"<p>To link the source <code>src</code> and the incrementer <code>inc</code>, the output socket <code>out_data</code> of the task <code>generate</code> of the module <code>src</code> should be \"bound\" to the input socket <code>in</code> of the task <code>increment</code> of the module <code>inc</code>.</p>"},{"location":"first_steps/#tasks-execution","title":"Tasks execution\u00b6","text":"<p>Now we can execute the tasks of each module.</p>"},{"location":"first_steps/#debug-mode-activation","title":"Debug mode activation\u00b6","text":"<p>You can see that the data is automatically transfered from the output of <code>generate</code> to the input of <code>increment</code>. The data printing can also be handled automatically by setting the <code>debug</code> property of the tasks to <code>true</code>.</p>"},{"location":"install/","title":"Installation","text":""},{"location":"install/#install-from-the-sources","title":"Install from the sources","text":"<p>Clone the repository <pre><code>git clone --recursive git@gitlab.inria.fr:fec/pystreampu.git\n</code></pre> then install the python interface of <code>StreamPU</code> using <code>pip3</code> <pre><code>pip3 install ./pystreampu\n</code></pre> If you want more information during compilation, use <code>-v</code> option of the <code>pip3</code> command.</p>"},{"location":"install/#install-with-fine-tuning-of-c-flags","title":"Install with fine-tuning of C++ flags","text":"<p>To install <code>streampu</code>compiled with custom flags, use the following syntax: <pre><code>pip3 install -Ccmake.define.YOUR_CMAKE_FLAG1=CONTENT1 -Ccmake.define.YOUR_CMAKE_FLAG2=CONTENT2 .\n</code></pre> where you can replace <code>YOUR_CMAKE_FLAG1</code>and <code>YOUR_CMAKE_FLAG2</code> by the flags you want and set <code>CONTENT1</code> and <code>CONTENT2</code> values.</p>"},{"location":"module/","title":"Module","text":"In\u00a0[2]: Copied! <pre>mdl = spu.incrementer(3)\n</pre> mdl = spu.incrementer(3) <ul> <li><code>name</code> (property) is the module name</li> </ul> In\u00a0[3]: Copied! <pre>print(mdl.name)\n</pre> print(mdl.name) <pre>Incrementer\n</pre> <ul> <li><code>tasks</code> (read only) is the list of every task of a module.</li> </ul> <p>The incrementer of our example has two tasks <code>increment</code> and <code>incrementf</code>.</p> In\u00a0[4]: Copied! <pre>[t.name for t in mdl.tasks]\n</pre> [t.name for t in mdl.tasks] Out[4]: <pre>['increment', 'incrementf']</pre> <ul> <li><code>n_frames</code> (property) is the number of frames processes at each task execution.</li> </ul> In\u00a0[5]: Copied! <pre>mdl.n_frames\n</pre> mdl.n_frames Out[5]: <pre>1</pre> In\u00a0[6]: Copied! <pre>mdl.increment\n</pre> mdl.increment Out[6]: <pre>&lt;streampu._ext.core.Task at 0x7f5da824a5b0&gt;</pre>"},{"location":"module/#module","title":"Module\u00b6","text":"<p>In this section, we present some basic attributes and methods for StreamPU modules similar to the ones from the C++ API.</p> <p><code>spu.Module</code> is a shortcut for <code>streampu._ext.core.Module</code> which is a binding for the class <code>spu::module::Module</code> of the C++ API.</p> <p>The Python API give access to some attributes and methods that are:</p> <ul> <li>directly bound from <code>streampu._ext.core.Module</code></li> <li>specific to the Python API</li> </ul> <p>In order to illustrate these ... an <code>spu.incrementer</code>...</p>"},{"location":"module/#main-attributes","title":"Main attributes\u00b6","text":""},{"location":"module/#attributes-from-the-python-api","title":"Attributes from the Python API\u00b6","text":""},{"location":"reference/","title":"Reference","text":"<p>This part of the project documentation focuses on an information-oriented approach. Use it as a reference for the technical implementation of the <code>StreamPU</code> project code.</p> <p>::: streampu._ext.core._Sequence ::: streampu.Socket</p>"},{"location":"sequence/","title":"Sequence","text":"In\u00a0[1]: Copied! <pre>import streampu as spu\n</pre> import streampu as spu"},{"location":"sequence/#sequence","title":"Sequence\u00b6","text":""},{"location":"socket/","title":"Socket","text":"In\u00a0[2]: Copied! <pre>x = spu.array([1,2,3,4])\nprint(x)\n</pre> x = spu.array([1,2,3,4]) print(x) <pre>[[1 2 3 4]]\n</pre> In\u00a0[3]: Copied! <pre>l = np.array([1,2,3,4], np.float32)\nx = spu.array(l)\nprint(\"A\", x.dtype, \"socket containing the data\", x)\nprint(repr(x))\n</pre> l = np.array([1,2,3,4], np.float32) x = spu.array(l) print(\"A\", x.dtype, \"socket containing the data\", x) print(repr(x)) <pre>A float32 socket containing the data [[1. 2. 3. 4.]]\nsocket([[1. 2. 3. 4.]], dtype=float32, name=data, task=Array.read)\n</pre> In\u00a0[4]: Copied! <pre>l[2] = 1\nx\n</pre> l[2] = 1 x Out[4]: <pre>socket([[1. 2. 1. 4.]], dtype=float32, name=data, task=Array.read)</pre> In\u00a0[5]: Copied! <pre>src = spu.source_random(8, dtype = spu.int64)\nx,_ = src.generate()\npx = x.numpy\nprint(px)\n</pre> src = spu.source_random(8, dtype = spu.int64) x,_ = src.generate() px = x.numpy print(px) <pre>[[1 1 1 1 1 1 1 1]]\n</pre> In\u00a0[6]: Copied! <pre>src.generate.exec()\nx\n</pre> src.generate.exec() x Out[6]: <pre>socket([[0 1 1 0 0 0 1 0]], dtype=int64, name=out_data, task=Source_random.generate)</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"socket/#socket","title":"Socket\u00b6","text":""},{"location":"socket/#python-interface","title":"Python interface\u00b6","text":""},{"location":"socket/#numpy-interface","title":"NumPy interface\u00b6","text":""},{"location":"socket/#from-numpy-to-streampu","title":"From NumPy to StreamPu\u00b6","text":""},{"location":"socket/#from-streampu-to-numpy","title":"From StreamPu to Numpy\u00b6","text":""},{"location":"task/","title":"Task","text":"In\u00a0[1]: Copied! <pre>import streampu as spu\nsrc = spu.source_random(8, dtype = spu.int64)\ngenerate = src[\"generate\"]\n</pre> import streampu as spu src = spu.source_random(8, dtype = spu.int64) generate = src[\"generate\"] <p>If you want to have some information about the tasks of <code>src</code> you can use <code>help</code>or <code>spu.help</code>.</p> In\u00a0[2]: Copied! <pre>generate.module\n\ngenerate.inputs\ngenerate.outputs\ngenerate.forwards\n\ngenerate.stats\ngenerate.avg_duration, generate.min_duration, generate.max_duration\ngenerate.n_calls\ngenerate.reset\n\ngenerate.debug\n\ngenerate.exec\n\n\n\ngenerate.out_data\n__call__\n</pre> generate.module  generate.inputs generate.outputs generate.forwards  generate.stats generate.avg_duration, generate.min_duration, generate.max_duration generate.n_calls generate.reset  generate.debug  generate.exec    generate.out_data __call__ <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[2], line 19\n     14 generate.exec\n     18 generate.out_data\n---&gt; 19 __call__\n\nNameError: name '__call__' is not defined</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"task/#task","title":"Task\u00b6","text":"<p>In this section we present some functionalities of <code>task</code> objects.</p>"}]}